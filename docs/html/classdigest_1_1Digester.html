<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>digest: digest::Digester&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">digest
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>digest</b></li><li class="navelem"><a class="el" href="classdigest_1_1Digester.html">Digester</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classdigest_1_1Digester-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">digest::Digester&lt; P &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for digest::Digester&lt; P &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdigest_1_1Digester.png" usemap="#digest::Digester_3C_20P_20_3E_map" alt=""/>
  <map id="digest::Digester_3C_20P_20_3E_map" name="digest::Digester_3C_20P_20_3E_map">
<area href="classdigest_1_1ModMin.html" alt="digest::ModMin&lt; P &gt;" shape="rect" coords="0,56,164,80"/>
<area href="classdigest_1_1WindowMin.html" alt="digest::WindowMin&lt; P, T &gt;" shape="rect" coords="174,56,338,80"/>
<area href="classdigest_1_1Syncmer.html" alt="digest::Syncmer&lt; P, T &gt;" shape="rect" coords="174,112,338,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a506f39bd2ad543c5d112dc0f5ca00640" id="r_a506f39bd2ad543c5d112dc0f5ca00640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a506f39bd2ad543c5d112dc0f5ca00640">Digester</a> (const char *seq, size_t len, unsigned k, size_t start=0, MinimizedHashType minimized_h=MinimizedHashType::CANON)</td></tr>
<tr class="separator:a506f39bd2ad543c5d112dc0f5ca00640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b026b422b243ec36dfb70b1118dc683" id="r_a4b026b422b243ec36dfb70b1118dc683"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b026b422b243ec36dfb70b1118dc683">Digester</a> (const std::string &amp;seq, unsigned k, size_t start=0, MinimizedHashType minimized_h=MinimizedHashType::CANON)</td></tr>
<tr class="separator:a4b026b422b243ec36dfb70b1118dc683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661a9725bd51816e21c9053c21acbe36" id="r_a661a9725bd51816e21c9053c21acbe36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661a9725bd51816e21c9053c21acbe36">get_is_valid_hash</a> ()</td></tr>
<tr class="separator:a661a9725bd51816e21c9053c21acbe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c07623971df41d6d44d901c8c81f4f6" id="r_a8c07623971df41d6d44d901c8c81f4f6"><td class="memItemLeft" align="right" valign="top"><a id="a8c07623971df41d6d44d901c8c81f4f6" name="a8c07623971df41d6d44d901c8c81f4f6"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>get_k</b> ()</td></tr>
<tr class="separator:a8c07623971df41d6d44d901c8c81f4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04952edc55179b4e287f0d9a8ffd052" id="r_af04952edc55179b4e287f0d9a8ffd052"><td class="memItemLeft" align="right" valign="top"><a id="af04952edc55179b4e287f0d9a8ffd052" name="af04952edc55179b4e287f0d9a8ffd052"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_len</b> ()</td></tr>
<tr class="separator:af04952edc55179b4e287f0d9a8ffd052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d6eadec5753c4b815e720804e699a" id="r_a433d6eadec5753c4b815e720804e699a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a433d6eadec5753c4b815e720804e699a">roll_one</a> ()</td></tr>
<tr class="memdesc:a433d6eadec5753c4b815e720804e699a"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves the internal pointer to the next valid k-mer, skipping over any k-mers that have contain a non ACTG character, and returns hash for that k-mer Time Complexity: O(1)  <br /></td></tr>
<tr class="separator:a433d6eadec5753c4b815e720804e699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbaa63689a9efeedd66fcd6285a3b8c" id="r_a1bbaa63689a9efeedd66fcd6285a3b8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bbaa63689a9efeedd66fcd6285a3b8c">roll_minimizer</a> (unsigned amount, std::vector&lt; uint32_t &gt; &amp;vec)=0</td></tr>
<tr class="memdesc:a1bbaa63689a9efeedd66fcd6285a3b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the positions, as defined by <a class="el" href="#aeb98424a350736b0c7a81a85cf441222">get_pos()</a>, of minimizers up to the amount specified  <br /></td></tr>
<tr class="separator:a1bbaa63689a9efeedd66fcd6285a3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c104095843a4dd2ff8e79859eddacc2" id="r_a9c104095843a4dd2ff8e79859eddacc2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c104095843a4dd2ff8e79859eddacc2">roll_minimizer</a> (unsigned amount, std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt; &gt; &amp;vec)=0</td></tr>
<tr class="memdesc:a9c104095843a4dd2ff8e79859eddacc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the positions (pair.first), as defined by <a class="el" href="#aeb98424a350736b0c7a81a85cf441222">get_pos()</a>, and the hashes (pair.second) of minimizers up to the amount specified  <br /></td></tr>
<tr class="separator:a9c104095843a4dd2ff8e79859eddacc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb98424a350736b0c7a81a85cf441222" id="r_aeb98424a350736b0c7a81a85cf441222"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb98424a350736b0c7a81a85cf441222">get_pos</a> ()</td></tr>
<tr class="separator:aeb98424a350736b0c7a81a85cf441222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a433e6ec0391098f5fc2565589e2236" id="r_a8a433e6ec0391098f5fc2565589e2236"><td class="memItemLeft" align="right" valign="top"><a id="a8a433e6ec0391098f5fc2565589e2236" name="a8a433e6ec0391098f5fc2565589e2236"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_chash</b> ()</td></tr>
<tr class="separator:a8a433e6ec0391098f5fc2565589e2236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fe13c297c198345b701aab08d216c0" id="r_af8fe13c297c198345b701aab08d216c0"><td class="memItemLeft" align="right" valign="top"><a id="af8fe13c297c198345b701aab08d216c0" name="af8fe13c297c198345b701aab08d216c0"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_fhash</b> ()</td></tr>
<tr class="separator:af8fe13c297c198345b701aab08d216c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ad0371a70cabaec5b9f5ef8836489b" id="r_a88ad0371a70cabaec5b9f5ef8836489b"><td class="memItemLeft" align="right" valign="top"><a id="a88ad0371a70cabaec5b9f5ef8836489b" name="a88ad0371a70cabaec5b9f5ef8836489b"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_rhash</b> ()</td></tr>
<tr class="separator:a88ad0371a70cabaec5b9f5ef8836489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c0db63c891b891181846eed10963da" id="r_ab3c0db63c891b891181846eed10963da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c0db63c891b891181846eed10963da">new_seq</a> (const char *seq, size_t len, size_t start)</td></tr>
<tr class="memdesc:ab3c0db63c891b891181846eed10963da"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces the current sequence with the new one, it's like starting over with a completely new string  <br /></td></tr>
<tr class="separator:ab3c0db63c891b891181846eed10963da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db7b7bc923eb48e5b855653bf69d9b" id="r_aa7db7b7bc923eb48e5b855653bf69d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7db7b7bc923eb48e5b855653bf69d9b">new_seq</a> (const std::string &amp;seq, size_t pos)</td></tr>
<tr class="memdesc:aa7db7b7bc923eb48e5b855653bf69d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">replaces the current sequence with the new one, it's like starting over with a completely new string  <br /></td></tr>
<tr class="separator:aa7db7b7bc923eb48e5b855653bf69d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdd5a8a29c0e479156b8d52ea1c32ed" id="r_a3fdd5a8a29c0e479156b8d52ea1c32ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdd5a8a29c0e479156b8d52ea1c32ed">append_seq</a> (const char *seq, size_t len)</td></tr>
<tr class="memdesc:a3fdd5a8a29c0e479156b8d52ea1c32ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulates the appending of a new sequence to the end of the old sequence The old string will no longer be stored, but the rolling hashes will be able to preceed as if the strings were appended Can only be called when you've reached the end of the current string i.e. if you're current sequence is ACTGAC, and you have reached the end of this sequence, and you call append_seq with the sequence CCGGCCGG, then the minimizers you will get after calling append_seq plus the minimizers you got from going through ACTGAC, will be equivalent to the minimizers you would have gotten from rolling across ACTGACCCGGCCGG  <br /></td></tr>
<tr class="separator:a3fdd5a8a29c0e479156b8d52ea1c32ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b59300cc23481fd8ed40d5fe247e8a" id="r_aa1b59300cc23481fd8ed40d5fe247e8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b59300cc23481fd8ed40d5fe247e8a">append_seq</a> (const std::string &amp;seq)</td></tr>
<tr class="memdesc:aa1b59300cc23481fd8ed40d5fe247e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulates the appending of a new sequence to the end of the old sequence The old string will no longer be stored, but the rolling hashes will be able to preceed as if the strings were appended Can only be called when you've reached the end of the current string i.e. if you're current sequence is ACTGAC, and you have reached the end of this sequence, and you call append_seq with the sequence CCGGCCGG, then the minimizers you will get after calling append_seq plus the minimizers you got from going through ACTGAC, will be equivalent to the minimizers you would have gotten from rolling across ACTGACCCGGCCGG  <br /></td></tr>
<tr class="separator:aa1b59300cc23481fd8ed40d5fe247e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a1452ff7df41fbb8f46070e77b978" id="r_a696a1452ff7df41fbb8f46070e77b978"><td class="memItemLeft" align="right" valign="top">MinimizedHashType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a696a1452ff7df41fbb8f46070e77b978">get_minimized_h</a> ()</td></tr>
<tr class="separator:a696a1452ff7df41fbb8f46070e77b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed14b0e621523c388b550f8da7688d35" id="r_aed14b0e621523c388b550f8da7688d35"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed14b0e621523c388b550f8da7688d35">get_sequence</a> ()</td></tr>
<tr class="separator:aed14b0e621523c388b550f8da7688d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2c53dd5f454485afb2198da6cb6f3f89" id="r_a2c53dd5f454485afb2198da6cb6f3f89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c53dd5f454485afb2198da6cb6f3f89">is_ACTG</a> (char in)</td></tr>
<tr class="separator:a2c53dd5f454485afb2198da6cb6f3f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd6daf175a36f74c19d5654f4e4d85b" id="r_a6fd6daf175a36f74c19d5654f4e4d85b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd6daf175a36f74c19d5654f4e4d85b">init_hash</a> ()</td></tr>
<tr class="memdesc:a6fd6daf175a36f74c19d5654f4e4d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that initializes the hash values at the first valid k-mer at or after start Sets is_valid_hash to be equal to its return value.  <br /></td></tr>
<tr class="separator:a6fd6daf175a36f74c19d5654f4e4d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e7120a88d88feee6db476f3b1fdce" id="r_ad64e7120a88d88feee6db476f3b1fdce"><td class="memItemLeft" align="right" valign="top"><a id="ad64e7120a88d88feee6db476f3b1fdce" name="ad64e7120a88d88feee6db476f3b1fdce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_seq_skip_over</b> (const char *seq, size_t len)</td></tr>
<tr class="separator:ad64e7120a88d88feee6db476f3b1fdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8c9053267e1968d23e30161a127d06" id="r_a3b8c9053267e1968d23e30161a127d06"><td class="memItemLeft" align="right" valign="top"><a id="a3b8c9053267e1968d23e30161a127d06" name="a3b8c9053267e1968d23e30161a127d06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_seq_write_over</b> (const char *seq, size_t len)</td></tr>
<tr class="separator:a3b8c9053267e1968d23e30161a127d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad193db03f5077b3e1d1e295b7bfcfc05" id="r_ad193db03f5077b3e1d1e295b7bfcfc05"><td class="memItemLeft" align="right" valign="top"><a id="ad193db03f5077b3e1d1e295b7bfcfc05" name="ad193db03f5077b3e1d1e295b7bfcfc05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_hash_skip_over</b> ()</td></tr>
<tr class="separator:ad193db03f5077b3e1d1e295b7bfcfc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0051a58132c4333c11b1a5ebe8506" id="r_a90d0051a58132c4333c11b1a5ebe8506"><td class="memItemLeft" align="right" valign="top"><a id="a90d0051a58132c4333c11b1a5ebe8506" name="a90d0051a58132c4333c11b1a5ebe8506"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_hash_write_over</b> ()</td></tr>
<tr class="separator:a90d0051a58132c4333c11b1a5ebe8506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337249d0e761f817fcea483d43c02a0" id="r_ac337249d0e761f817fcea483d43c02a0"><td class="memItemLeft" align="right" valign="top"><a id="ac337249d0e761f817fcea483d43c02a0" name="ac337249d0e761f817fcea483d43c02a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>roll_one_skip_over</b> ()</td></tr>
<tr class="separator:ac337249d0e761f817fcea483d43c02a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5f0ce4a23ea3aeffeb6656c2d0d5cb" id="r_acb5f0ce4a23ea3aeffeb6656c2d0d5cb"><td class="memItemLeft" align="right" valign="top"><a id="acb5f0ce4a23ea3aeffeb6656c2d0d5cb" name="acb5f0ce4a23ea3aeffeb6656c2d0d5cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>roll_one_write_over</b> ()</td></tr>
<tr class="separator:acb5f0ce4a23ea3aeffeb6656c2d0d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aab8ba0195ebef8815cd1033c41a73e00" id="r_aab8ba0195ebef8815cd1033c41a73e00"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, 256 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8ba0195ebef8815cd1033c41a73e00">actg</a></td></tr>
<tr class="separator:aab8ba0195ebef8815cd1033c41a73e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add84631319df92a6cc383a8b0101fbba" id="r_add84631319df92a6cc383a8b0101fbba"><td class="memItemLeft" align="right" valign="top"><a id="add84631319df92a6cc383a8b0101fbba" name="add84631319df92a6cc383a8b0101fbba"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>seq</b></td></tr>
<tr class="separator:add84631319df92a6cc383a8b0101fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d96846ef203d77507027109b075bfa" id="r_a90d96846ef203d77507027109b075bfa"><td class="memItemLeft" align="right" valign="top"><a id="a90d96846ef203d77507027109b075bfa" name="a90d96846ef203d77507027109b075bfa"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>len</b></td></tr>
<tr class="separator:a90d96846ef203d77507027109b075bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7f0d5ed82c43cb82f70681355f4a9" id="r_a8bf7f0d5ed82c43cb82f70681355f4a9"><td class="memItemLeft" align="right" valign="top"><a id="a8bf7f0d5ed82c43cb82f70681355f4a9" name="a8bf7f0d5ed82c43cb82f70681355f4a9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>offset</b></td></tr>
<tr class="separator:a8bf7f0d5ed82c43cb82f70681355f4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc429ff86215f529b8388bcc8b092ba6" id="r_afc429ff86215f529b8388bcc8b092ba6"><td class="memItemLeft" align="right" valign="top"><a id="afc429ff86215f529b8388bcc8b092ba6" name="afc429ff86215f529b8388bcc8b092ba6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>start</b></td></tr>
<tr class="separator:afc429ff86215f529b8388bcc8b092ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bbaa66a8ff6c7f13c2c1221e865b2e" id="r_a08bbaa66a8ff6c7f13c2c1221e865b2e"><td class="memItemLeft" align="right" valign="top"><a id="a08bbaa66a8ff6c7f13c2c1221e865b2e" name="a08bbaa66a8ff6c7f13c2c1221e865b2e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>end</b></td></tr>
<tr class="separator:a08bbaa66a8ff6c7f13c2c1221e865b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabe16df44eb10dfcd8dd20aabc3ed50" id="r_aeabe16df44eb10dfcd8dd20aabc3ed50"><td class="memItemLeft" align="right" valign="top"><a id="aeabe16df44eb10dfcd8dd20aabc3ed50" name="aeabe16df44eb10dfcd8dd20aabc3ed50"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>chash</b></td></tr>
<tr class="separator:aeabe16df44eb10dfcd8dd20aabc3ed50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc32ed392a9bd7780f4d6552307b9d84" id="r_adc32ed392a9bd7780f4d6552307b9d84"><td class="memItemLeft" align="right" valign="top"><a id="adc32ed392a9bd7780f4d6552307b9d84" name="adc32ed392a9bd7780f4d6552307b9d84"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>fhash</b></td></tr>
<tr class="separator:adc32ed392a9bd7780f4d6552307b9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1383dfeec1ae3cd68f3cf0984f566d8d" id="r_a1383dfeec1ae3cd68f3cf0984f566d8d"><td class="memItemLeft" align="right" valign="top"><a id="a1383dfeec1ae3cd68f3cf0984f566d8d" name="a1383dfeec1ae3cd68f3cf0984f566d8d"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>rhash</b></td></tr>
<tr class="separator:a1383dfeec1ae3cd68f3cf0984f566d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6643d7f8edc8fba47a3ffe763c990a7" id="r_ae6643d7f8edc8fba47a3ffe763c990a7"><td class="memItemLeft" align="right" valign="top"><a id="ae6643d7f8edc8fba47a3ffe763c990a7" name="ae6643d7f8edc8fba47a3ffe763c990a7"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:ae6643d7f8edc8fba47a3ffe763c990a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76daebf34abcf15ccdf0beb7360b2cf" id="r_af76daebf34abcf15ccdf0beb7360b2cf"><td class="memItemLeft" align="right" valign="top"><a id="af76daebf34abcf15ccdf0beb7360b2cf" name="af76daebf34abcf15ccdf0beb7360b2cf"></a>
std::deque&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>c_outs</b></td></tr>
<tr class="separator:af76daebf34abcf15ccdf0beb7360b2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fadbb2311108015830826bd147e74b" id="r_ad9fadbb2311108015830826bd147e74b"><td class="memItemLeft" align="right" valign="top"><a id="ad9fadbb2311108015830826bd147e74b" name="ad9fadbb2311108015830826bd147e74b"></a>
MinimizedHashType&#160;</td><td class="memItemRight" valign="bottom"><b>minimized_h</b></td></tr>
<tr class="separator:ad9fadbb2311108015830826bd147e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3694cfd7d557f2f34bab510d9b47f935" id="r_a3694cfd7d557f2f34bab510d9b47f935"><td class="memItemLeft" align="right" valign="top"><a id="a3694cfd7d557f2f34bab510d9b47f935" name="a3694cfd7d557f2f34bab510d9b47f935"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_hash</b> = false</td></tr>
<tr class="separator:a3694cfd7d557f2f34bab510d9b47f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a506f39bd2ad543c5d112dc0f5ca00640" name="a506f39bd2ad543c5d112dc0f5ca00640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506f39bd2ad543c5d112dc0f5ca00640">&#9670;&#160;</a></span>Digester() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::Digester </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>start</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MinimizedHashType</td>          <td class="paramname"><span class="paramname"><em>minimized_h</em><span class="paramdefsep"> = </span><span class="paramdefval">MinimizedHashType::CANON</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>char pointer poitning to the c-string of DNA sequence to be hashed. </td></tr>
    <tr><td class="paramname">len</td><td>length of seq. </td></tr>
    <tr><td class="paramname">k</td><td>k-mer size. </td></tr>
    <tr><td class="paramname">start</td><td>0-indexed position in seq to start hashing from. </td></tr>
    <tr><td class="paramname">minimized_h</td><td>hash to be minimized, 0 for canoncial, 1 for forward, 2 for reverse</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1BadConstructionException.html">BadConstructionException</a></td><td>Thrown if k is less than 4, or if the starting position is after the end of the string or if minimized_h is greater than 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b026b422b243ec36dfb70b1118dc683" name="a4b026b422b243ec36dfb70b1118dc683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b026b422b243ec36dfb70b1118dc683">&#9670;&#160;</a></span>Digester() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::Digester </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>start</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MinimizedHashType</td>          <td class="paramname"><span class="paramname"><em>minimized_h</em><span class="paramdefsep"> = </span><span class="paramdefval">MinimizedHashType::CANON</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>reference to std string of DNA sequence to be hashed. </td></tr>
    <tr><td class="paramname">k</td><td>k-mer size. </td></tr>
    <tr><td class="paramname">start</td><td>0-indexed position in seq to start hashing from. </td></tr>
    <tr><td class="paramname">minimized_h</td><td>hash to be minimized, 0 for canoncial, 1 for forward, 2 for reverse</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1BadConstructionException.html">BadConstructionException</a></td><td>Thrown if k is less than 4, or if the starting position is after the end of the string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fdd5a8a29c0e479156b8d52ea1c32ed" name="a3fdd5a8a29c0e479156b8d52ea1c32ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdd5a8a29c0e479156b8d52ea1c32ed">&#9670;&#160;</a></span>append_seq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::append_seq </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simulates the appending of a new sequence to the end of the old sequence The old string will no longer be stored, but the rolling hashes will be able to preceed as if the strings were appended Can only be called when you've reached the end of the current string i.e. if you're current sequence is ACTGAC, and you have reached the end of this sequence, and you call append_seq with the sequence CCGGCCGG, then the minimizers you will get after calling append_seq plus the minimizers you got from going through ACTGAC, will be equivalent to the minimizers you would have gotten from rolling across ACTGACCCGGCCGG </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>C string of DNA sequence to be appended </td></tr>
    <tr><td class="paramname">len</td><td>length of the sequence</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1NotRolledTillEndException.html">NotRolledTillEndException</a></td><td>Thrown when the internal iterator is not at the end of the current sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1b59300cc23481fd8ed40d5fe247e8a" name="aa1b59300cc23481fd8ed40d5fe247e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b59300cc23481fd8ed40d5fe247e8a">&#9670;&#160;</a></span>append_seq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::append_seq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simulates the appending of a new sequence to the end of the old sequence The old string will no longer be stored, but the rolling hashes will be able to preceed as if the strings were appended Can only be called when you've reached the end of the current string i.e. if you're current sequence is ACTGAC, and you have reached the end of this sequence, and you call append_seq with the sequence CCGGCCGG, then the minimizers you will get after calling append_seq plus the minimizers you got from going through ACTGAC, will be equivalent to the minimizers you would have gotten from rolling across ACTGACCCGGCCGG </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>std string of DNA sequence to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1NotRolledTillEndException.html">NotRolledTillEndException</a></td><td>Thrown when the internal iterator is not at the end of the current sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a661a9725bd51816e21c9053c21acbe36" name="a661a9725bd51816e21c9053c21acbe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661a9725bd51816e21c9053c21acbe36">&#9670;&#160;</a></span>get_is_valid_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::get_is_valid_hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>bool, true if values of the 3 hashes are meaningful, false otherwise, i.e. the object wasn't able to initialize with a valid hash or <a class="el" href="#a433d6eadec5753c4b815e720804e699a" title="moves the internal pointer to the next valid k-mer, skipping over any k-mers that have contain a non ...">roll_one()</a> was called when already at end of sequence </dd></dl>

</div>
</div>
<a id="a696a1452ff7df41fbb8f46070e77b978" name="a696a1452ff7df41fbb8f46070e77b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696a1452ff7df41fbb8f46070e77b978">&#9670;&#160;</a></span>get_minimized_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MinimizedHashType <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::get_minimized_h </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>unsigned, a number representing the hash you are minimizing, 0 for canoncial, 1 for forward, 2 for reverse </dd></dl>

</div>
</div>
<a id="aeb98424a350736b0c7a81a85cf441222" name="aeb98424a350736b0c7a81a85cf441222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98424a350736b0c7a81a85cf441222">&#9670;&#160;</a></span>get_pos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::get_pos </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>current index of the first character of the current kmer that has been hashed strings that have been appended onto each other count as 1 big string, i.e. if you first had a string of length 10 and then appended another string of length 20, and the index of the first character of the current k-mer is at index 4, 0-indexed, in the second string, then it will return 14 </dd></dl>

</div>
</div>
<a id="aed14b0e621523c388b550f8da7688d35" name="aed14b0e621523c388b550f8da7688d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed14b0e621523c388b550f8da7688d35">&#9670;&#160;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::get_sequence </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const char* representation of the sequence </dd></dl>

</div>
</div>
<a id="a6fd6daf175a36f74c19d5654f4e4d85b" name="a6fd6daf175a36f74c19d5654f4e4d85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd6daf175a36f74c19d5654f4e4d85b">&#9670;&#160;</a></span>init_hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::init_hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that initializes the hash values at the first valid k-mer at or after start Sets is_valid_hash to be equal to its return value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool, true on success, a valid hash is initialized, false otherwise </dd></dl>

</div>
</div>
<a id="a2c53dd5f454485afb2198da6cb6f3f89" name="a2c53dd5f454485afb2198da6cb6f3f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c53dd5f454485afb2198da6cb6f3f89">&#9670;&#160;</a></span>is_ACTG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::is_ACTG </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>char to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool, true if in is an upper or lowercase ACTG character, false otherwise </dd></dl>

</div>
</div>
<a id="ab3c0db63c891b891181846eed10963da" name="ab3c0db63c891b891181846eed10963da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c0db63c891b891181846eed10963da">&#9670;&#160;</a></span>new_seq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::new_seq </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces the current sequence with the new one, it's like starting over with a completely new string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>char pointer to new sequence to be hashed </td></tr>
    <tr><td class="paramname">len</td><td>length of the new sequence </td></tr>
    <tr><td class="paramname">start</td><td>position in new sequence to start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1BadConstructionException.html">BadConstructionException</a></td><td>thrown if the starting position is greater than the length of the string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7db7b7bc923eb48e5b855653bf69d9b" name="aa7db7b7bc923eb48e5b855653bf69d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db7b7bc923eb48e5b855653bf69d9b">&#9670;&#160;</a></span>new_seq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::new_seq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>replaces the current sequence with the new one, it's like starting over with a completely new string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>std string reference to the new sequence to be hashed </td></tr>
    <tr><td class="paramname">start</td><td>position in new sequence to start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classdigest_1_1BadConstructionException.html">BadConstructionException</a></td><td>thrown if the starting position is greater than the length of the string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c104095843a4dd2ff8e79859eddacc2" name="a9c104095843a4dd2ff8e79859eddacc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c104095843a4dd2ff8e79859eddacc2">&#9670;&#160;</a></span>roll_minimizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::roll_minimizer </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>amount</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the positions (pair.first), as defined by <a class="el" href="#aeb98424a350736b0c7a81a85cf441222">get_pos()</a>, and the hashes (pair.second) of minimizers up to the amount specified </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>number of minimizers you want to generate </td></tr>
    <tr><td class="paramname">vec</td><td>a reference to a vector of size_t's, the positions returned will go there </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdigest_1_1ModMin.html#a3d292932508ce65dadf80cfe1d9f5b34">digest::ModMin&lt; P &gt;</a>, <a class="el" href="classdigest_1_1Syncmer.html#ae966953db4fb68cfea89819df9d5e53b">digest::Syncmer&lt; P, T &gt;</a>, and <a class="el" href="classdigest_1_1WindowMin.html#a7886989cb0b9b3bb732dfeb333fa2bba">digest::WindowMin&lt; P, T &gt;</a>.</p>

</div>
</div>
<a id="a1bbaa63689a9efeedd66fcd6285a3b8c" name="a1bbaa63689a9efeedd66fcd6285a3b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbaa63689a9efeedd66fcd6285a3b8c">&#9670;&#160;</a></span>roll_minimizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::roll_minimizer </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>amount</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the positions, as defined by <a class="el" href="#aeb98424a350736b0c7a81a85cf441222">get_pos()</a>, of minimizers up to the amount specified </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>number of minimizers you want to generate </td></tr>
    <tr><td class="paramname">vec</td><td>a reference to a vector of size_t's, the positions returned will go there </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdigest_1_1ModMin.html#a87c2431cdabb982db55b759e1034a8ad">digest::ModMin&lt; P &gt;</a>, <a class="el" href="classdigest_1_1Syncmer.html#a89172ad3aea6f949b9e56f1839f61e14">digest::Syncmer&lt; P, T &gt;</a>, and <a class="el" href="classdigest_1_1WindowMin.html#a4928f279856e0339743148a7b39f5b56">digest::WindowMin&lt; P, T &gt;</a>.</p>

</div>
</div>
<a id="a433d6eadec5753c4b815e720804e699a" name="a433d6eadec5753c4b815e720804e699a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433d6eadec5753c4b815e720804e699a">&#9670;&#160;</a></span>roll_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::roll_one </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moves the internal pointer to the next valid k-mer, skipping over any k-mers that have contain a non ACTG character, and returns hash for that k-mer Time Complexity: O(1) </p>
<dl class="section return"><dt>Returns</dt><dd>bool, true if we were able generate a valid hash, false otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aab8ba0195ebef8815cd1033c41a73e00" name="aab8ba0195ebef8815cd1033c41a73e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8ba0195ebef8815cd1033c41a73e00">&#9670;&#160;</a></span>actg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BadCharPolicy P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;bool, 256&gt; <a class="el" href="classdigest_1_1Digester.html">digest::Digester</a>&lt; P &gt;::actg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, </div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/digest/<a class="el" href="digester_8hpp_source.html">digester.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
